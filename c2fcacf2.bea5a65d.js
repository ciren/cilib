(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{172:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(1),i=n(9),r=(n(0),n(193)),o={},l={id:"design/entity",title:"entity",description:"# Entity",source:"@site/docs/design/entity.md",permalink:"/docs/design/entity"},c=[],s={rightToc:c},p="wrapper";function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)(p,Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"entity"},"Entity"),Object(r.b)("p",null,"Within swarm intelligence, evolutionary computation and other, similar\nalgorithms, there is always a metaphor that the algorithm is based on.\nUsing this metaphor, the participants within the algorithm are also\nappropriately named. For example, within a Particle Swarm Optimization (PSO),\nthe participants are referred to as Particles, with Individuals being\nused in both Differential Evolution (DE) and Genetic Algorithms (GA).\nMany other examples can easily be identified in available literature."),Object(r.b)("p",null,"It is not practical to have several representations for a very similar\nconcept used within these algorithms. Based on experimentation within CIlib,\na common structure was identified that could be used to represent the\nparticipants for these metaphor-based population based algorithms. We\nrefer, collectively, to these algorithm participants as ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," instances."),Object(r.b)("p",null,"An ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," is a simple structure that contains and manages two very\nspecific things:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"A ",Object(r.b)("inlineCode",{parentName:"li"},"Position[A]")," within the current search space of the problem"),Object(r.b)("li",{parentName:"ul"},'A "state" that contains all addition data required by the ',Object(r.b)("inlineCode",{parentName:"li"},"Entity"),"\nwhich is not managed by the ",Object(r.b)("inlineCode",{parentName:"li"},"Position[A]"),".")),Object(r.b)("p",null,"The resulting ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," is therefore represented by the following\nparameterized data type:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"final case class Entity[S,A](state: S, pos: Position[A])\n")),Object(r.b)("p",null,"where ",Object(r.b)("inlineCode",{parentName:"p"},"S")," is the type of the state that the ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," maintains,\nand ",Object(r.b)("inlineCode",{parentName:"p"},"A")," is the type of the dimension element within a ",Object(r.b)("inlineCode",{parentName:"p"},"Position[A]"),"."),Object(r.b)("p",null,"The state value differs between ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," instances. A Particle requires\na velocity vector and a previous best position vector, whilst an Individual,\nrequires no additional data other that a ",Object(r.b)("inlineCode",{parentName:"p"},"Position"),"."),Object(r.b)("p",null,"Because the value of ",Object(r.b)("inlineCode",{parentName:"p"},"S")," within the ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," can be anything, it is\nnot possible to have predefined functions that allow extraction of data\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"S")," parameter type. In order to enable this, optics are applied to\nthe instances."),Object(r.b)("p",null,"Within the definitions of CIlib, an Individual is nothing more than an\n",Object(r.b)("inlineCode",{parentName:"p"},"Entity[Unit,A]")," for some type ",Object(r.b)("inlineCode",{parentName:"p"},"A"),". As the type states, there is no\nstate value for the ",Object(r.b)("inlineCode",{parentName:"p"},"Entity"),", and it is defined to be ",Object(r.b)("inlineCode",{parentName:"p"},"Unit")," - a type that\nexists with a single value (expressed as ",Object(r.b)("inlineCode",{parentName:"p"},"()"),"), which is uninteresting."),Object(r.b)("p",null,"Some functions use ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," instances, but\nconstrain the usage based on the shape of the ",Object(r.b)("inlineCode",{parentName:"p"},"S")," type parameter within the\n",Object(r.b)("inlineCode",{parentName:"p"},"Entity[S,A]"),". As mentioned within the discussion of\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:""}),"lenses and optics"),", a typeclass ",Object(r.b)("inlineCode",{parentName:"p"},"HasMemory")," is defined to allow a state\nto contain information about some kind of memory for an ",Object(r.b)("inlineCode",{parentName:"p"},"Entity"),". A data\nstructure that provides this memory for a Particle is ",Object(r.b)("inlineCode",{parentName:"p"},"Mem[A]"),", and is simply\nthe case class:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"case class Mem[A](b: Position[A], v: Position[A])\n")),Object(r.b)("p",null,"There already exists an instance of ",Object(r.b)("inlineCode",{parentName:"p"},"HasMemory")," defined for the ",Object(r.b)("inlineCode",{parentName:"p"},"Mem"),"\ndata structure. Let's have a look at some usage:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"// Lets create a function that expects the provided Entity to have\n// a memory within it's state parameter\ndef foo[S](x: Entity[S,Double])(implicit mem: HasMemory[S,Double]) =\n  mem._memory.get(x.state)\n\n// Now, lets create some Entity instances\nval interval = Interval(-5.12,5.12)^3\n// interval: scalaz.NonEmptyList[Interval[Double]] = NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\nval individual = Position.createPosition(interval).map(p => Entity((), p))\n// individual: RVar[Entity[Unit, Double]] = cilib.RVar$$anon$4@69ea3848\nval particle = Position.createPosition(interval).map(p => Entity(Mem(p, p.zeroed), p))\n// particle: RVar[Entity[Mem[Double], Double]] = cilib.RVar$$anon$4@5bd969cf\n")),Object(r.b)("p",null,"Take note of the value held by the state parameter\nin the resulting entity instances above.\nWe would need to run the ",Object(r.b)("inlineCode",{parentName:"p"},"RVar")," computation to get the individual and particle\nvalues, or we can simply ",Object(r.b)("inlineCode",{parentName:"p"},"map")," the function ",Object(r.b)("inlineCode",{parentName:"p"},"foo")," into the ",Object(r.b)("inlineCode",{parentName:"p"},"RVar"),", changing\nthe result of the computation to a ",Object(r.b)("inlineCode",{parentName:"p"},"RVar")," which when executed will return the memory\nof the ",Object(r.b)("inlineCode",{parentName:"p"},"Entity"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"particle.map(p => foo(p)) // This works as expected: particles have a memory\n// res0: RVar[Position[Double]] = cilib.RVar$$anon$4@31aada5a\n")),Object(r.b)("p",null,"Because ",Object(r.b)("inlineCode",{parentName:"p"},"individual")," does not have a memory defined, the following will fail.\nThis failure is not only expected but required to ensure that incorrect usages\nare disallowed as soon as possible."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"individual.map(i => foo(i))\n// error: A HasMemory instance cannot be found for the provided state type Unit\n// individual.map(i => foo(i))\n//                     ^^^^^^\n")),Object(r.b)("p",null,"There are several optics predefined that allow for the zooming in of values in\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Position")," as well as the state of an ",Object(r.b)("inlineCode",{parentName:"p"},"Entity"),". Of course a user could define\ntheir own optics, and it is recommended when custom state types are used,\nin order to work with the ",Object(r.b)("inlineCode",{parentName:"p"},"Entity")," data."))}b.isMDXComponent=!0},193:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),p=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},b=function(e){var t=p(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),b=p(n),d=a,u=b["".concat(o,".").concat(d)]||b[d]||m[d]||r;return n?i.a.createElement(u,l({ref:t},s,{components:n})):i.a.createElement(u,l({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);