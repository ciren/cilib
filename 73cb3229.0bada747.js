(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{155:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return b}));var o=t(1),a=t(9),i=(t(0),t(193)),r={},s={id:"design/position",title:"position",description:"# Position",source:"@site/docs/design/position.md",permalink:"/docs/design/position"},l=[],c={rightToc:l},p="wrapper";function b(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)(p,Object(o.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"position"},"Position"),Object(i.b)("p",null,"Candidate solution vectors within a search space are the basic pieces of\ninformation that computational algorithms maintain and, includes feature\nvectors that represent training patterns in a neural network.\nWithin population based algorithms, a collection of algorithm\nparticipants are employed in a search of the problem space. Each represents\na possible solution to the problem at hand, and may be in one of two\npossible states:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},'It may be a "point" in the search space where no other information about\nthe point is known, except for the value of the multi-dimensional vector\nrepresenting the position within the search space'),Object(i.b)("li",{parentName:"ol"},'It may be a possible "solution", where the position in the multi-dimensional\nsearch space is known but, an additional value representing the\n"quality" of the vector is also maintained. This "quality" is\nreferred to as the fitness of the candidate solution.')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Position")," is a data structure that encodes the above two cases\nexactly, allowing a ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," to either be a ",Object(i.b)("inlineCode",{parentName:"p"},"Point")," or a ",Object(i.b)("inlineCode",{parentName:"p"},"Solution"),".\nFurther more, ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," is an Algebraic Data Type (ADT), whereby the set\nof possible representations may not be extended further (and is enforced\nby the compiler). Any changes to a ",Object(i.b)("inlineCode",{parentName:"p"},"Solution")," will yield a ",Object(i.b)("inlineCode",{parentName:"p"},"Point")," - the\nnew ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," has not yet had a fitness calculated, i.e: the\nquality of the ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," is an unknown."),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"Position"),", within a search space, can be created by providing the search\nspace bounds to the ",Object(i.b)("inlineCode",{parentName:"p"},"createPosition")," function. The search space must have\nat least a single dimension (the zero-dimensional search is trivial) and, a\n",Object(i.b)("inlineCode",{parentName:"p"},"NonEmptyList[Interval[Double]]")," represents the search space bounds.\nA ",Object(i.b)("inlineCode",{parentName:"p"},"NonEmptyList")," is a list that is guaranteed to have at least one\ncontained element."),Object(i.b)("p",null,"A search space is determined by a list of ",Object(i.b)("inlineCode",{parentName:"p"},"Interval")," instances (provided\nby ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:""}),"spire"),"), one for each dimension. The ",Object(i.b)("inlineCode",{parentName:"p"},"Interval")," need not be the same\nfor each dimension and differing ",Object(i.b)("inlineCode",{parentName:"p"},"Interval"),"s may be placed together in a\n",Object(i.b)("inlineCode",{parentName:"p"},"NonEmptyList")," to define the problem search space. As it is rather common\nto define a search space where an interval repeats ",Object(i.b)("inlineCode",{parentName:"p"},"n")," times, some syntax\nhas been added to the ",Object(i.b)("inlineCode",{parentName:"p"},"Interval"),' data constructor to allow for repetition in\na more convenient way. This syntax models the\ntext parser used in CIlib 1.0 for the "domain string", but is now available\nat the type level and verifiable during compilation.\nAs an example, let\'s create a 30-dimensional vector in the interval\n$',"[-5.12, 5.12]","$:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-scala"}),"Interval(-5.12,5.12)^30\n// res0: NonEmptyList[Interval[Double]] = NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n")),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," may now be constructed, as we know what the bounds of the search\nspace are"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-scala"}),"Position.createPosition(Interval(-5.12,5.12)^30)\n// res1: RVar[Position[Double]] = cilib.RVar$$anon$4@649b2b76\n")),Object(i.b)("p",null,"The result of creating a ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," is a ",Object(i.b)("inlineCode",{parentName:"p"},"RVar[Position[A]]")," computation,\nas the ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," is created with a vector placed randomly within the search\nspace bounds. Furthermore, the type of the dimension elements within the\n",Object(i.b)("inlineCode",{parentName:"p"},"Position")," is inferred, based on the provided ",Object(i.b)("inlineCode",{parentName:"p"},"Interval")," information (in this\nexample a ",Object(i.b)("inlineCode",{parentName:"p"},"Double"),")."),Object(i.b)("p",null,"The normal vector operations are provided, as syntax, to make the usage\nsimpler and to mirror the mathematics defined in literature more closely.\nBelow are some examples of combining ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," instances. Take careful\nnote of the return value for the different cases of ",Object(i.b)("inlineCode",{parentName:"p"},"Position"),". In order\nto evaluate the quality of a ",Object(i.b)("inlineCode",{parentName:"p"},"Position")," an ",Object(i.b)("inlineCode",{parentName:"p"},"Eval")," instance is required."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-scala"}),"val e = Eval.unconstrained[NonEmptyList,Double](pos => Feasible(pos.map(x => x * x).suml))\n// e: Eval[NonEmptyList, Double] = Unconstrained(\n//   <function1>,\n//   cilib.EvalInstances$$anon$1@68b56da8\n// )\n\n// a is a Point and b is a Solution\nval (_, (a, b)) =\n  (for {\n    a <- Position.createPosition(Interval(-5.12,5.12)^3)\n    b <- Position.createPosition(Interval(-5.12,5.12)^3).flatMap(p => Position.eval(e.eval, p))\n  } yield (a, b)).run(RNG.init(1234L))\n// a: Position[Double] = Point(\n//   NonEmpty[0.3223506002436043,1.284861083896021,-1.1568782389221028],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n// b: Position[Double] = Solution(\n//   NonEmpty[-1.4431717739767316,-3.7375555203377644,4.753584873023057],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]],\n//   Single(Feasible(38.648635181844085), List())\n// )\n\n// Unary syntax to negate a Position\n-a\n// res2: Position[Double] = Point(\n//   NonEmpty[-0.3223506002436043,-1.284861083896021,1.1568782389221028],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n\n// Add Point and Solution\na + b\n// res3: Position[Double] = Point(\n//   NonEmpty[-1.1208211737331273,-2.4526944364417433,3.5967066341009546],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n\n// Add Point and Point\na + a\n// res4: Position[Double] = Point(\n//   NonEmpty[0.6447012004872086,2.569722167792042,-2.3137564778442057],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n\n// Add Solution and Solution\nb + b\n// res5: Position[Double] = Point(\n//   NonEmpty[-2.886343547953463,-7.475111040675529,9.507169746046115],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n\n// Subtract Solution from Point\na - b\n// res6: Position[Double] = Point(\n//   NonEmpty[1.7655223742203359,5.022416604233785,-5.910463111945161],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n\n// a * b does not compile. Vector multiplication makes little sense.\n// If the objective was to use pairwise multiplication, there is another\n// structure called `Pointwise` which can be used to achieve this operation\n// via the `Algebra` object.\nAlgebra.pointwise(a, b)\n// res7: Position[Double] = Point(\n//   NonEmpty[-0.46520728759602664,-4.802239636982737,-5.499318896469663],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n\n// Scalar multiplication\n3.0 *: a\n// res8: Position[Double] = Point(\n//   NonEmpty[0.9670518007308129,3.854583251688063,-3.4706347167663085],\n//   NonEmpty[[-5.12, 5.12],[-5.12, 5.12],[-5.12, 5.12]]\n// )\n")),Object(i.b)("p",null,"Whenever a ",Object(i.b)("inlineCode",{parentName:"p"},"Position"),' is moved to a "new point" within the search space,\nit requires re-evaluation.'))}b.isMDXComponent=!0},193:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return h}));var o=t(0),a=t.n(o);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=a.a.createContext({}),p=function(e){var n=a.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s({},n,{},e)),t},b=function(e){var n=p(e.components);return a.a.createElement(c.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(t),m=o,u=b["".concat(r,".").concat(m)]||b[m]||d[m]||i;return t?a.a.createElement(u,s({ref:n},c,{components:t})):a.a.createElement(u,s({ref:n},c))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);